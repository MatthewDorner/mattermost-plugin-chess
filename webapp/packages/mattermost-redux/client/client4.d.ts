import { ClusterInfo, AnalyticsRow } from "../types/admin";
import type { AppBinding, AppCallRequest, AppCallResponse, AppCallType } from "../types/apps";
import { Audit } from "../types/audits";
import { UserAutocomplete, AutocompleteSuggestion } from "../types/autocomplete";
import { Bot, BotPatch } from "../types/bots";
import { Product, Subscription, CloudCustomer, Address, CloudCustomerPatch, Invoice, SubscriptionStats } from "../types/cloud";
import { ChannelCategory, OrderedChannelCategories } from "../types/channel_categories";
import { Channel, ChannelMembership, ChannelModeration, ChannelModerationPatch, ChannelStats, ChannelsWithTotalCount, ChannelUnread, ChannelViewResponse, ChannelWithTeamData, ChannelSearchOpts } from "../types/channels";
import { Options, StatusOK, ClientResponse } from "../types/client4";
import { Compliance } from "../types/compliance";
import { ClientConfig, DataRetentionPolicy, License, AdminConfig, EnvironmentConfig } from "../types/config";
import { CustomEmoji } from "../types/emojis";
import { ServerError } from "../types/errors";
import { FileInfo, FileUploadResponse, FileSearchResults } from "../types/files";
import { Group, GroupPatch, GroupSyncable, MixedUnlinkedGroup, SyncablePatch, UsersWithGroupsAndCount, GroupsWithCount } from "../types/groups";
import { PostActionResponse } from "../types/integration_actions";
import { Command, CommandArgs, CommandResponse, DialogSubmission, IncomingWebhook, OAuthApp, OutgoingWebhook, SubmitDialogResponse } from "../types/integrations";
import { Job } from "../types/jobs";
import { MfaSecret } from "../types/mfa";
import { ClientPluginManifest, PluginsResponse, PluginStatus } from "../types/plugins";
import type { MarketplaceApp, MarketplacePlugin } from "../types/marketplace";
import { Post, PostList, PostSearchResults, OpenGraphMetadata } from "../types/posts";
import { PreferenceType } from "../types/preferences";
import { Reaction } from "../types/reactions";
import { Role } from "../types/roles";
import { SamlCertificateStatus, SamlMetadataResponse } from "../types/saml";
import { Scheme } from "../types/schemes";
import { Session } from "../types/sessions";
import { GetTeamMembersOpts, Team, TeamInviteWithError, TeamMembership, TeamMemberWithError, TeamStats, TeamsWithCount, TeamUnread, TeamSearchOpts } from "../types/teams";
import { TermsOfService } from "../types/terms_of_service";
import { AuthChangeResponse, UserAccessToken, UserProfile, UsersStats, UserStatus, GetFilteredUsersStatsOpts, UserCustomStatus } from "../types/users";
import { $ID, RelationOneToOne } from "../types/utilities";
import { ProductNotices } from "../types/product_notices";
import { DataRetentionCustomPolicies, CreateDataRetentionCustomPolicy, PatchDataRetentionCustomPolicy, PatchDataRetentionCustomPolicyTeams, PatchDataRetentionCustomPolicyChannels, GetDataRetentionCustomPoliciesRequest } from "../types/data_retention";
import { TelemetryHandler } from './telemetry';
import { UserThreadList, UserThread, UserThreadWithPost } from "../types/threads";
export declare const HEADER_X_VERSION_ID = "X-Version-Id";
export declare const DEFAULT_LIMIT_BEFORE = 30;
export declare const DEFAULT_LIMIT_AFTER = 30;
export default class Client4 {
    logToConsole: boolean;
    serverVersion: string;
    clusterId: string;
    token: string;
    csrf: string;
    url: string;
    urlVersion: string;
    userAgent: string | null;
    enableLogging: boolean;
    defaultHeaders: {
        [x: string]: string;
    };
    userId: string;
    diagnosticId: string;
    includeCookies: boolean;
    translations: {
        connectionError: string;
        unknownError: string;
    };
    userRoles?: string;
    telemetryHandler?: TelemetryHandler;
    getUrl(): string;
    getAbsoluteUrl(baseUrl: string): string;
    setUrl(url: string): void;
    setUserAgent(userAgent: string): void;
    getToken(): string;
    setToken(token: string): void;
    setCSRF(csrfToken: string): void;
    setAcceptLanguage(locale: string): void;
    setEnableLogging(enable: boolean): void;
    setIncludeCookies(include: boolean): void;
    setUserId(userId: string): void;
    setUserRoles(roles: string): void;
    setDiagnosticId(diagnosticId: string): void;
    setTelemetryHandler(telemetryHandler?: TelemetryHandler): void;
    getServerVersion(): string;
    getUrlVersion(): string;
    getBaseRoute(): string;
    getAppsProxyRoute(): string;
    getUsersRoute(): string;
    getUserRoute(userId: string): string;
    getTeamsRoute(): string;
    getTeamRoute(teamId: string): string;
    getTeamSchemeRoute(teamId: string): string;
    getTeamNameRoute(teamName: string): string;
    getTeamMembersRoute(teamId: string): string;
    getTeamMemberRoute(teamId: string, userId: string): string;
    getChannelsRoute(): string;
    getChannelRoute(channelId: string): string;
    getChannelMembersRoute(channelId: string): string;
    getChannelMemberRoute(channelId: string, userId: string): string;
    getChannelSchemeRoute(channelId: string): string;
    getChannelCategoriesRoute(userId: string, teamId: string): string;
    getPostsRoute(): string;
    getPostRoute(postId: string): string;
    getReactionsRoute(): string;
    getCommandsRoute(): string;
    getFilesRoute(): string;
    getFileRoute(fileId: string): string;
    getPreferencesRoute(userId: string): string;
    getIncomingHooksRoute(): string;
    getIncomingHookRoute(hookId: string): string;
    getOutgoingHooksRoute(): string;
    getOutgoingHookRoute(hookId: string): string;
    getOAuthRoute(): string;
    getOAuthAppsRoute(): string;
    getOAuthAppRoute(appId: string): string;
    getEmojisRoute(): string;
    getEmojiRoute(emojiId: string): string;
    getBrandRoute(): string;
    getBrandImageUrl(timestamp: string): string;
    getDataRetentionRoute(): string;
    getJobsRoute(): string;
    getPluginsRoute(): string;
    getPluginRoute(pluginId: string): string;
    getPluginsMarketplaceRoute(): string;
    getRolesRoute(): string;
    getTimezonesRoute(): string;
    getSchemesRoute(): string;
    getRedirectLocationRoute(): string;
    getBotsRoute(): string;
    getBotRoute(botUserId: string): string;
    getGroupsRoute(): string;
    getGroupRoute(groupID: string): string;
    getNoticesRoute(): string;
    getCloudRoute(): string;
    getUserThreadsRoute(userID: string, teamID: string): string;
    getUserThreadRoute(userId: string, teamId: string, threadId: string): string;
    getCSRFFromCookie(): string;
    getOptions(options: Options): {
        headers: {
            [x: string]: string;
        };
        method?: string | undefined;
        url?: string | undefined;
        credentials?: "omit" | "same-origin" | "include" | undefined;
        body?: any;
    };
    createUser: (user: UserProfile, token: string, inviteId: string, redirect: string) => Promise<UserProfile>;
    patchMe: (userPatch: Partial<UserProfile>) => Promise<UserProfile>;
    patchUser: (userPatch: Partial<UserProfile> & {
        id: string;
    }) => Promise<UserProfile>;
    updateUser: (user: UserProfile) => Promise<UserProfile>;
    promoteGuestToUser: (userId: string) => Promise<StatusOK>;
    demoteUserToGuest: (userId: string) => Promise<StatusOK>;
    updateUserRoles: (userId: string, roles: string) => Promise<StatusOK>;
    updateUserMfa: (userId: string, activate: boolean, code: string) => Promise<StatusOK>;
    updateUserPassword: (userId: string, currentPassword: string, newPassword: string) => Promise<StatusOK>;
    resetUserPassword: (token: string, newPassword: string) => Promise<StatusOK>;
    getKnownUsers: () => Promise<string[]>;
    sendPasswordResetEmail: (email: string) => Promise<StatusOK>;
    updateUserActive: (userId: string, active: boolean) => Promise<StatusOK>;
    uploadProfileImage: (userId: string, imageData: File) => Promise<StatusOK>;
    setDefaultProfileImage: (userId: string) => Promise<StatusOK>;
    verifyUserEmail: (token: string) => Promise<StatusOK>;
    updateMyTermsOfServiceStatus: (termsOfServiceId: string, accepted: boolean) => Promise<StatusOK>;
    getTermsOfService: () => Promise<TermsOfService>;
    createTermsOfService: (text: string) => Promise<TermsOfService>;
    sendVerificationEmail: (email: string) => Promise<StatusOK>;
    login: (loginId: string, password: string, token?: string, deviceId?: string, ldapOnly?: boolean) => Promise<UserProfile>;
    loginById: (id: string, password: string, token?: string, deviceId?: string) => Promise<UserProfile>;
    logout: () => Promise<Response>;
    getProfiles: (page?: number, perPage?: number, options?: {}) => Promise<UserProfile[]>;
    getProfilesByIds: (userIds: string[], options?: {}) => Promise<UserProfile[]>;
    getProfilesByUsernames: (usernames: string[]) => Promise<UserProfile[]>;
    getProfilesInTeam: (teamId: string, page?: number, perPage?: number, sort?: string, options?: {}) => Promise<UserProfile[]>;
    getProfilesNotInTeam: (teamId: string, groupConstrained: boolean, page?: number, perPage?: number) => Promise<UserProfile[]>;
    getProfilesWithoutTeam: (page?: number, perPage?: number, options?: {}) => Promise<UserProfile[]>;
    getProfilesInChannel: (channelId: string, page?: number, perPage?: number, sort?: string, options?: {
        active?: boolean;
    }) => Promise<UserProfile[]>;
    getProfilesInGroupChannels: (channelsIds: string[]) => Promise<Record<string, UserProfile[]>>;
    getProfilesNotInChannel: (teamId: string, channelId: string, groupConstrained: boolean, page?: number, perPage?: number) => Promise<UserProfile[]>;
    getProfilesInGroup: (groupId: string, page?: number, perPage?: number) => Promise<UserProfile[]>;
    getMe: () => Promise<UserProfile>;
    getUser: (userId: string) => Promise<UserProfile>;
    getUserByUsername: (username: string) => Promise<UserProfile>;
    getUserByEmail: (email: string) => Promise<UserProfile>;
    getProfilePictureUrl: (userId: string, lastPictureUpdate: number) => string;
    getDefaultProfilePictureUrl: (userId: string) => string;
    autocompleteUsers: (name: string, teamId: string, channelId: string, options?: {
        limit: number;
    }) => Promise<UserAutocomplete>;
    getSessions: (userId: string) => Promise<Session[]>;
    revokeSession: (userId: string, sessionId: string) => Promise<StatusOK>;
    revokeAllSessionsForUser: (userId: string) => Promise<StatusOK>;
    revokeSessionsForAllUsers: () => Promise<StatusOK>;
    getUserAudits: (userId: string, page?: number, perPage?: number) => Promise<Audit[]>;
    checkUserMfa: (loginId: string) => Promise<{
        mfa_required: boolean;
    }>;
    generateMfaSecret: (userId: string) => Promise<MfaSecret>;
    attachDevice: (deviceId: string) => Promise<StatusOK>;
    searchUsers: (term: string, options: any) => Promise<UserProfile[]>;
    getStatusesByIds: (userIds: string[]) => Promise<UserStatus[]>;
    getStatus: (userId: string) => Promise<UserStatus>;
    updateStatus: (status: UserStatus) => Promise<UserStatus>;
    updateCustomStatus: (customStatus: UserCustomStatus) => Promise<unknown>;
    unsetCustomStatus: () => Promise<unknown>;
    removeRecentCustomStatus: (customStatus: UserCustomStatus) => Promise<unknown>;
    switchEmailToOAuth: (service: string, email: string, password: string, mfaCode?: string) => Promise<AuthChangeResponse>;
    switchOAuthToEmail: (currentService: string, email: string, password: string) => Promise<AuthChangeResponse>;
    switchEmailToLdap: (email: string, emailPassword: string, ldapId: string, ldapPassword: string, mfaCode?: string) => Promise<AuthChangeResponse>;
    switchLdapToEmail: (ldapPassword: string, email: string, emailPassword: string, mfaCode?: string) => Promise<AuthChangeResponse>;
    getAuthorizedOAuthApps: (userId: string) => Promise<OAuthApp[]>;
    authorizeOAuthApp: (responseType: string, clientId: string, redirectUri: string, state: string, scope: string) => Promise<void>;
    deauthorizeOAuthApp: (clientId: string) => Promise<StatusOK>;
    createUserAccessToken: (userId: string, description: string) => Promise<UserAccessToken>;
    getUserAccessToken: (tokenId: string) => Promise<UserAccessToken>;
    getUserAccessTokensForUser: (userId: string, page?: number, perPage?: number) => Promise<UserAccessToken[]>;
    getUserAccessTokens: (page?: number, perPage?: number) => Promise<UserAccessToken[]>;
    revokeUserAccessToken: (tokenId: string) => Promise<StatusOK>;
    disableUserAccessToken: (tokenId: string) => Promise<StatusOK>;
    enableUserAccessToken: (tokenId: string) => Promise<StatusOK>;
    createTeam: (team: Team) => Promise<Team>;
    deleteTeam: (teamId: string) => Promise<StatusOK>;
    updateTeam: (team: Team) => Promise<Team>;
    patchTeam: (team: Partial<Team> & {
        id: string;
    }) => Promise<Team>;
    regenerateTeamInviteId: (teamId: string) => Promise<Team>;
    updateTeamScheme: (teamId: string, schemeId: string) => Promise<StatusOK>;
    checkIfTeamExists: (teamName: string) => Promise<{
        exists: boolean;
    }>;
    getTeams: (page?: number, perPage?: number, includeTotalCount?: boolean) => Promise<Team[] | TeamsWithCount>;
    searchTeams: (term: string, opts: TeamSearchOpts) => Promise<Team[] | TeamsWithCount>;
    getTeam: (teamId: string) => Promise<Team>;
    getTeamByName: (teamName: string) => Promise<Team>;
    getMyTeams: () => Promise<Team[]>;
    getTeamsForUser: (userId: string) => Promise<Team[]>;
    getMyTeamMembers: () => Promise<TeamMembership[]>;
    getMyTeamUnreads: () => Promise<TeamUnread[]>;
    getTeamMembers: (teamId: string, page: number | undefined, perPage: number | undefined, options: GetTeamMembersOpts) => Promise<TeamMembership>;
    getTeamMembersForUser: (userId: string) => Promise<TeamMembership[]>;
    getTeamMember: (teamId: string, userId: string) => Promise<TeamMembership>;
    getTeamMembersByIds: (teamId: string, userIds: string[]) => Promise<TeamMembership[]>;
    addToTeam: (teamId: string, userId: string) => Promise<TeamMembership>;
    addToTeamFromInvite: (token?: string, inviteId?: string) => Promise<TeamMembership>;
    addUsersToTeam: (teamId: string, userIds: string[]) => Promise<TeamMembership[]>;
    addUsersToTeamGracefully: (teamId: string, userIds: string[]) => Promise<TeamMemberWithError[]>;
    joinTeam: (inviteId: string) => Promise<TeamMembership>;
    removeFromTeam: (teamId: string, userId: string) => Promise<StatusOK>;
    getTeamStats: (teamId: string) => Promise<TeamStats>;
    getTotalUsersStats: () => Promise<UsersStats>;
    getFilteredUsersStats: (options: GetFilteredUsersStatsOpts) => Promise<UsersStats>;
    invalidateAllEmailInvites: () => Promise<StatusOK>;
    getTeamInviteInfo: (inviteId: string) => Promise<{
        display_name: string;
        description: string;
        name: string;
        id: string;
    }>;
    updateTeamMemberRoles: (teamId: string, userId: string, roles: string[]) => Promise<StatusOK>;
    sendEmailInvitesToTeam: (teamId: string, emails: string[]) => Promise<StatusOK>;
    sendEmailGuestInvitesToChannels: (teamId: string, channelIds: string[], emails: string[], message: string) => Promise<StatusOK>;
    sendEmailInvitesToTeamGracefully: (teamId: string, emails: string[]) => Promise<TeamInviteWithError>;
    sendEmailGuestInvitesToChannelsGracefully: (teamId: string, channelIds: string[], emails: string[], message: string) => Promise<TeamInviteWithError>;
    importTeam: (teamId: string, file: File, importFrom: string) => Promise<{
        results: string;
    }>;
    getTeamIconUrl: (teamId: string, lastTeamIconUpdate: number) => string;
    setTeamIcon: (teamId: string, imageData: File) => Promise<StatusOK>;
    removeTeamIcon: (teamId: string) => Promise<StatusOK>;
    updateTeamMemberSchemeRoles: (teamId: string, userId: string, isSchemeUser: boolean, isSchemeAdmin: boolean) => Promise<StatusOK>;
    getAllChannels: (page?: number, perPage?: number, notAssociatedToGroup?: string, excludeDefaultChannels?: boolean, includeTotalCount?: boolean, includeDeleted?: boolean) => Promise<ChannelsWithTotalCount | ChannelWithTeamData[]>;
    createChannel: (channel: Channel) => Promise<Channel>;
    createDirectChannel: (userIds: string[]) => Promise<Channel>;
    createGroupChannel: (userIds: string[]) => Promise<Channel>;
    deleteChannel: (channelId: string) => Promise<StatusOK>;
    unarchiveChannel: (channelId: string) => Promise<Channel>;
    updateChannel: (channel: Channel) => Promise<Channel>;
    convertChannelToPrivate: (channelId: string) => Promise<Channel>;
    updateChannelPrivacy: (channelId: string, privacy: any) => Promise<Channel>;
    patchChannel: (channelId: string, channelPatch: Partial<Channel>) => Promise<Channel>;
    updateChannelNotifyProps: (props: any) => Promise<StatusOK>;
    updateChannelScheme: (channelId: string, schemeId: string) => Promise<StatusOK>;
    getChannel: (channelId: string) => Promise<Channel>;
    getChannelByName: (teamId: string, channelName: string, includeDeleted?: boolean) => Promise<Channel>;
    getChannelByNameAndTeamName: (teamName: string, channelName: string, includeDeleted?: boolean) => Promise<Channel>;
    getChannels: (teamId: string, page?: number, perPage?: number) => Promise<Channel[]>;
    getArchivedChannels: (teamId: string, page?: number, perPage?: number) => Promise<Channel[]>;
    getMyChannels: (teamId: string, includeDeleted?: boolean) => Promise<Channel[]>;
    getMyChannelMember: (channelId: string) => Promise<ChannelMembership>;
    getMyChannelMembers: (teamId: string) => Promise<ChannelMembership[]>;
    getChannelMembers: (channelId: string, page?: number, perPage?: number) => Promise<ChannelMembership[]>;
    getChannelTimezones: (channelId: string) => Promise<string[]>;
    getChannelMember: (channelId: string, userId: string) => Promise<ChannelMembership>;
    getChannelMembersByIds: (channelId: string, userIds: string[]) => Promise<ChannelMembership[]>;
    addToChannel: (userId: string, channelId: string, postRootId?: string) => Promise<ChannelMembership>;
    removeFromChannel: (userId: string, channelId: string) => Promise<StatusOK>;
    updateChannelMemberRoles: (channelId: string, userId: string, roles: string) => Promise<StatusOK>;
    getChannelStats: (channelId: string) => Promise<ChannelStats>;
    getChannelModerations: (channelId: string) => Promise<ChannelModeration[]>;
    patchChannelModerations: (channelId: string, channelModerationsPatch: ChannelModerationPatch[]) => Promise<ChannelModeration[]>;
    getChannelMemberCountsByGroup: (channelId: string, includeTimezones: boolean) => Promise<Record<string, import("../types/channels").ChannelMemberCountByGroup>>;
    viewMyChannel: (channelId: string, prevChannelId?: string | undefined) => Promise<ChannelViewResponse>;
    autocompleteChannels: (teamId: string, name: string) => Promise<Channel[]>;
    autocompleteChannelsForSearch: (teamId: string, name: string) => Promise<Channel[]>;
    searchChannels: (teamId: string, term: string) => Promise<Channel[]>;
    searchArchivedChannels: (teamId: string, term: string) => Promise<Channel[]>;
    searchAllChannels: (term: string, opts?: ChannelSearchOpts) => Promise<Channel[] | ChannelsWithTotalCount>;
    searchGroupChannels: (term: string) => Promise<Channel[]>;
    updateChannelMemberSchemeRoles: (channelId: string, userId: string, isSchemeUser: boolean, isSchemeAdmin: boolean) => Promise<StatusOK>;
    getChannelCategories: (userId: string, teamId: string) => Promise<OrderedChannelCategories>;
    createChannelCategory: (userId: string, teamId: string, category: Partial<ChannelCategory>) => Promise<ChannelCategory>;
    updateChannelCategories: (userId: string, teamId: string, categories: ChannelCategory[]) => Promise<ChannelCategory[]>;
    getChannelCategoryOrder: (userId: string, teamId: string) => Promise<string[]>;
    updateChannelCategoryOrder: (userId: string, teamId: string, categoryOrder: string[]) => Promise<string[]>;
    getChannelCategory: (userId: string, teamId: string, categoryId: string) => Promise<ChannelCategory>;
    updateChannelCategory: (userId: string, teamId: string, category: ChannelCategory) => Promise<ChannelCategory>;
    deleteChannelCategory: (userId: string, teamId: string, categoryId: string) => Promise<ChannelCategory>;
    createPost: (post: Post) => Promise<Post>;
    updatePost: (post: Post) => Promise<Post>;
    getPost: (postId: string) => Promise<Post>;
    patchPost: (postPatch: Partial<Post> & {
        id: string;
    }) => Promise<Post>;
    deletePost: (postId: string) => Promise<StatusOK>;
    getPostThread: (postId: string, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPosts: (channelId: string, page?: number, perPage?: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPostsUnread: (channelId: string, userId: string, limitAfter?: number, limitBefore?: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPostsSince: (channelId: string, since: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPostsBefore: (channelId: string, postId: string, page?: number, perPage?: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getPostsAfter: (channelId: string, postId: string, page?: number, perPage?: number, fetchThreads?: boolean, collapsedThreads?: boolean, collapsedThreadsExtended?: boolean) => Promise<PostList>;
    getUserThreads: (userId: string | undefined, teamId: $ID<Team>, { before, after, pageSize, extended, deleted, unread, since, }: {
        before?: string | undefined;
        after?: string | undefined;
        pageSize?: number | undefined;
        extended?: boolean | undefined;
        deleted?: boolean | undefined;
        unread?: boolean | undefined;
        since?: number | undefined;
    }) => Promise<UserThreadList>;
    getUserThread: (userId: string, teamId: string, threadId: string, extended?: boolean) => Promise<UserThreadWithPost>;
    getThreadMentionCountsByChannel: (userId: string, teamId: string) => Promise<Record<string, number>>;
    updateThreadsReadForUser: (userId: string, teamId: string) => Promise<StatusOK>;
    updateThreadReadForUser: (userId: string, teamId: string, threadId: string, timestamp: number) => Promise<UserThread>;
    updateThreadFollowForUser: (userId: string, teamId: string, threadId: string, state: boolean) => Promise<StatusOK>;
    getFileInfosForPost: (postId: string) => Promise<FileInfo[]>;
    getFlaggedPosts: (userId: string, channelId?: string, teamId?: string, page?: number, perPage?: number) => Promise<PostList>;
    getPinnedPosts: (channelId: string) => Promise<PostList>;
    markPostAsUnread: (userId: string, postId: string) => Promise<ChannelUnread>;
    pinPost: (postId: string) => Promise<StatusOK>;
    unpinPost: (postId: string) => Promise<StatusOK>;
    addReaction: (userId: string, postId: string, emojiName: string) => Promise<Reaction>;
    removeReaction: (userId: string, postId: string, emojiName: string) => Promise<StatusOK>;
    getReactionsForPost: (postId: string) => Promise<Reaction[]>;
    searchPostsWithParams: (teamId: string, params: any) => Promise<PostSearchResults>;
    searchPosts: (teamId: string, terms: string, isOrSearch: boolean) => Promise<PostSearchResults>;
    searchFilesWithParams: (teamId: string, params: any) => Promise<FileSearchResults>;
    searchFiles: (teamId: string, terms: string, isOrSearch: boolean) => Promise<FileSearchResults>;
    getOpenGraphMetadata: (url: string) => Promise<OpenGraphMetadata>;
    doPostAction: (postId: string, actionId: string, selectedOption?: string) => Promise<PostActionResponse>;
    doPostActionWithCookie: (postId: string, actionId: string, actionCookie: string, selectedOption?: string) => Promise<PostActionResponse>;
    getFileUrl(fileId: string, timestamp: number): string;
    getFileThumbnailUrl(fileId: string, timestamp: number): string;
    getFilePreviewUrl(fileId: string, timestamp: number): string;
    uploadFile: (fileFormData: any, formBoundary: string) => Promise<FileUploadResponse>;
    getFilePublicLink: (fileId: string) => Promise<{
        link: string;
    }>;
    savePreferences: (userId: string, preferences: PreferenceType[]) => Promise<StatusOK>;
    getMyPreferences: () => Promise<PreferenceType>;
    deletePreferences: (userId: string, preferences: PreferenceType[]) => Promise<StatusOK>;
    ping: () => Promise<{
        status: string;
    }>;
    upgradeToEnterprise: () => Promise<StatusOK>;
    upgradeToEnterpriseStatus: () => Promise<{
        percentage: number;
        error: string | null;
    }>;
    restartServer: () => Promise<StatusOK>;
    logClientError: (message: string, level?: string) => Promise<{
        message: string;
    }>;
    getClientConfigOld: () => Promise<ClientConfig>;
    getClientLicenseOld: () => Promise<Record<string, string>>;
    getWarnMetricsStatus: () => Promise<unknown>;
    sendWarnMetricAck: (warnMetricId: string, forceAckVal: boolean) => Promise<unknown>;
    getTranslations: (url: string) => Promise<Record<string, string>>;
    getWebSocketUrl: () => string;
    createIncomingWebhook: (hook: IncomingWebhook) => Promise<IncomingWebhook>;
    getIncomingWebhook: (hookId: string) => Promise<IncomingWebhook>;
    getIncomingWebhooks: (teamId?: string, page?: number, perPage?: number) => Promise<IncomingWebhook[]>;
    removeIncomingWebhook: (hookId: string) => Promise<StatusOK>;
    updateIncomingWebhook: (hook: IncomingWebhook) => Promise<IncomingWebhook>;
    createOutgoingWebhook: (hook: OutgoingWebhook) => Promise<OutgoingWebhook>;
    getOutgoingWebhook: (hookId: string) => Promise<OutgoingWebhook>;
    getOutgoingWebhooks: (channelId?: string, teamId?: string, page?: number, perPage?: number) => Promise<OutgoingWebhook[]>;
    removeOutgoingWebhook: (hookId: string) => Promise<StatusOK>;
    updateOutgoingWebhook: (hook: OutgoingWebhook) => Promise<OutgoingWebhook>;
    regenOutgoingHookToken: (id: string) => Promise<OutgoingWebhook>;
    getCommandsList: (teamId: string) => Promise<Command[]>;
    getCommandAutocompleteSuggestionsList: (userInput: string, teamId: string, commandArgs: CommandArgs) => Promise<AutocompleteSuggestion[]>;
    getAutocompleteCommandsList: (teamId: string, page?: number, perPage?: number) => Promise<Command[]>;
    getCustomTeamCommands: (teamId: string) => Promise<Command[]>;
    executeCommand: (command: string, commandArgs: CommandArgs) => Promise<CommandResponse>;
    addCommand: (command: Command) => Promise<Command>;
    editCommand: (command: Command) => Promise<Command>;
    regenCommandToken: (id: string) => Promise<{
        token: string;
    }>;
    deleteCommand: (id: string) => Promise<StatusOK>;
    createOAuthApp: (app: OAuthApp) => Promise<OAuthApp>;
    editOAuthApp: (app: OAuthApp) => Promise<OAuthApp>;
    getOAuthApps: (page?: number, perPage?: number) => Promise<OAuthApp[]>;
    getOAuthApp: (appId: string) => Promise<OAuthApp>;
    getOAuthAppInfo: (appId: string) => Promise<OAuthApp>;
    deleteOAuthApp: (appId: string) => Promise<StatusOK>;
    regenOAuthAppSecret: (appId: string) => Promise<OAuthApp>;
    submitInteractiveDialog: (data: DialogSubmission) => Promise<SubmitDialogResponse>;
    createCustomEmoji: (emoji: CustomEmoji, imageData: File) => Promise<CustomEmoji>;
    getCustomEmoji: (id: string) => Promise<CustomEmoji>;
    getCustomEmojiByName: (name: string) => Promise<CustomEmoji>;
    getCustomEmojis: (page?: number, perPage?: number, sort?: string) => Promise<CustomEmoji[]>;
    deleteCustomEmoji: (emojiId: string) => Promise<StatusOK>;
    getSystemEmojiImageUrl: (filename: string) => string;
    getCustomEmojiImageUrl: (id: string) => string;
    searchCustomEmoji: (term: string, options?: {}) => Promise<CustomEmoji[]>;
    autocompleteCustomEmoji: (name: string) => Promise<CustomEmoji[]>;
    getTimezones: () => Promise<string[]>;
    getDataRetentionPolicy: () => Promise<DataRetentionPolicy>;
    getDataRetentionCustomPolicies: (page?: number, perPage?: number) => Promise<GetDataRetentionCustomPoliciesRequest>;
    getDataRetentionCustomPolicy: (id: string) => Promise<DataRetentionCustomPolicies>;
    searchDataRetentionCustomPolicyChannels: (policyId: string, term: string, opts: ChannelSearchOpts) => Promise<DataRetentionCustomPolicies>;
    searchDataRetentionCustomPolicyTeams: (policyId: string, term: string, opts: TeamSearchOpts) => Promise<DataRetentionCustomPolicies>;
    getDataRetentionCustomPolicyTeams: (id: string, page?: number, perPage?: number, includeTotalCount?: boolean) => Promise<Team[]>;
    getDataRetentionCustomPolicyChannels: (id: string, page?: number, perPage?: number) => Promise<{
        channels: Channel[];
        total_count: number;
    }>;
    createDataRetentionPolicy: (policy: CreateDataRetentionCustomPolicy) => Promise<DataRetentionCustomPolicies>;
    updateDataRetentionPolicy: (id: string, policy: PatchDataRetentionCustomPolicy) => Promise<DataRetentionCustomPolicies>;
    addDataRetentionPolicyTeams: (id: string, policy: PatchDataRetentionCustomPolicyTeams) => Promise<DataRetentionCustomPolicies>;
    removeDataRetentionPolicyTeams: (id: string, policy: PatchDataRetentionCustomPolicyTeams) => Promise<DataRetentionCustomPolicies>;
    addDataRetentionPolicyChannels: (id: string, policy: PatchDataRetentionCustomPolicyChannels) => Promise<DataRetentionCustomPolicies>;
    removeDataRetentionPolicyChannels: (id: string, policy: PatchDataRetentionCustomPolicyChannels) => Promise<DataRetentionCustomPolicies>;
    getJob: (id: string) => Promise<Job>;
    getJobs: (page?: number, perPage?: number) => Promise<Job[]>;
    getJobsByType: (type: string, page?: number, perPage?: number) => Promise<Job[]>;
    createJob: (job: Job) => Promise<Job>;
    cancelJob: (id: string) => Promise<StatusOK>;
    getLogs: (page?: number, perPage?: number) => Promise<string[]>;
    getAudits: (page?: number, perPage?: number) => Promise<Audit[]>;
    getConfig: () => Promise<AdminConfig>;
    updateConfig: (config: AdminConfig) => Promise<AdminConfig>;
    reloadConfig: () => Promise<StatusOK>;
    getEnvironmentConfig: () => Promise<EnvironmentConfig>;
    testEmail: (config: AdminConfig) => Promise<StatusOK>;
    testSiteURL: (siteURL: string) => Promise<StatusOK>;
    testS3Connection: (config: ClientConfig) => Promise<StatusOK>;
    invalidateCaches: () => Promise<StatusOK>;
    recycleDatabase: () => Promise<StatusOK>;
    createComplianceReport: (job: Partial<Compliance>) => Promise<Compliance>;
    getComplianceReport: (reportId: string) => Promise<Compliance>;
    getComplianceReports: (page?: number, perPage?: number) => Promise<Compliance[]>;
    uploadBrandImage: (imageData: File) => Promise<StatusOK>;
    deleteBrandImage: () => Promise<StatusOK>;
    getClusterStatus: () => Promise<ClusterInfo[]>;
    testLdap: () => Promise<StatusOK>;
    syncLdap: () => Promise<StatusOK>;
    getLdapGroups: (page?: number, perPage?: number, opts?: {}) => Promise<{
        count: number;
        groups: MixedUnlinkedGroup[];
    }>;
    linkLdapGroup: (key: string) => Promise<Group>;
    unlinkLdapGroup: (key: string) => Promise<StatusOK>;
    getSamlCertificateStatus: () => Promise<SamlCertificateStatus>;
    uploadPublicSamlCertificate: (fileData: File) => Promise<StatusOK>;
    uploadPrivateSamlCertificate: (fileData: File) => Promise<StatusOK>;
    uploadPublicLdapCertificate: (fileData: File) => Promise<StatusOK>;
    uploadPrivateLdapCertificate: (fileData: File) => Promise<StatusOK>;
    uploadIdpSamlCertificate: (fileData: File) => Promise<StatusOK>;
    deletePublicSamlCertificate: () => Promise<StatusOK>;
    deletePrivateSamlCertificate: () => Promise<StatusOK>;
    deletePublicLdapCertificate: () => Promise<StatusOK>;
    deletePrivateLdapCertificate: () => Promise<StatusOK>;
    deleteIdpSamlCertificate: () => Promise<StatusOK>;
    testElasticsearch: (config: ClientConfig) => Promise<StatusOK>;
    purgeElasticsearchIndexes: () => Promise<StatusOK>;
    purgeBleveIndexes: () => Promise<StatusOK>;
    uploadLicense: (fileData: File) => Promise<License>;
    removeLicense: () => Promise<StatusOK>;
    getAnalytics: (name?: string, teamId?: string) => Promise<AnalyticsRow[]>;
    getRole: (roleId: string) => Promise<Role>;
    getRoleByName: (roleName: string) => Promise<Role>;
    getRolesByNames: (rolesNames: string[]) => Promise<Role[]>;
    patchRole: (roleId: string, rolePatch: Partial<Role>) => Promise<Role>;
    getSchemes: (scope?: string, page?: number, perPage?: number) => Promise<Scheme[]>;
    createScheme: (scheme: Scheme) => Promise<Scheme>;
    getScheme: (schemeId: string) => Promise<Scheme>;
    deleteScheme: (schemeId: string) => Promise<StatusOK>;
    patchScheme: (schemeId: string, schemePatch: Partial<Scheme>) => Promise<Scheme>;
    getSchemeTeams: (schemeId: string, page?: number, perPage?: number) => Promise<Team[]>;
    getSchemeChannels: (schemeId: string, page?: number, perPage?: number) => Promise<Channel[]>;
    uploadPlugin: (fileData: File, force?: boolean) => Promise<{
        id: string;
        name: string;
        description?: string | undefined;
        homepage_url?: string | undefined;
        support_url?: string | undefined;
        release_notes_url?: string | undefined;
        icon_path?: string | undefined;
        version: string;
        min_server_version?: string | undefined;
        server?: import("../types/plugins").PluginManifestServer | undefined;
        backend?: import("../types/plugins").PluginManifestServer | undefined;
        webapp?: import("../types/plugins").PluginManifestWebapp | undefined;
        settings_schema?: import("../types/plugins").PluginSettingsSchema | undefined;
        props?: Record<string, any> | undefined;
    }>;
    installPluginFromUrl: (pluginDownloadUrl: string, force?: boolean) => Promise<{
        id: string;
        name: string;
        description?: string | undefined;
        homepage_url?: string | undefined;
        support_url?: string | undefined;
        release_notes_url?: string | undefined;
        icon_path?: string | undefined;
        version: string;
        min_server_version?: string | undefined;
        server?: import("../types/plugins").PluginManifestServer | undefined;
        backend?: import("../types/plugins").PluginManifestServer | undefined;
        webapp?: import("../types/plugins").PluginManifestWebapp | undefined;
        settings_schema?: import("../types/plugins").PluginSettingsSchema | undefined;
        props?: Record<string, any> | undefined;
    }>;
    getPlugins: () => Promise<PluginsResponse>;
    getMarketplacePlugins: (filter: string, localOnly?: boolean) => Promise<MarketplacePlugin[]>;
    installMarketplacePlugin: (id: string, version: string) => Promise<MarketplacePlugin>;
    getMarketplaceApps: (filter: string) => Promise<MarketplaceApp[]>;
    getPluginStatuses: () => Promise<PluginStatus[]>;
    removePlugin: (pluginId: string) => Promise<StatusOK>;
    getWebappPlugins: () => Promise<ClientPluginManifest[]>;
    enablePlugin: (pluginId: string) => Promise<StatusOK>;
    disablePlugin: (pluginId: string) => Promise<StatusOK>;
    linkGroupSyncable: (groupID: string, syncableID: string, syncableType: string, patch: SyncablePatch) => Promise<GroupSyncable>;
    unlinkGroupSyncable: (groupID: string, syncableID: string, syncableType: string) => Promise<StatusOK>;
    getGroupSyncables: (groupID: string, syncableType: string) => Promise<GroupSyncable[]>;
    getGroup: (groupID: string) => Promise<Group>;
    getGroupStats: (groupID: string) => Promise<Group>;
    getGroups: (filterAllowReference?: boolean, page?: number, perPage?: number) => Promise<Group[]>;
    getGroupsByUserId: (userID: string) => Promise<Group[]>;
    getGroupsNotAssociatedToTeam: (teamID: string, q?: string, page?: number, perPage?: number) => Promise<Group[]>;
    getGroupsNotAssociatedToChannel: (channelID: string, q?: string, page?: number, perPage?: number, filterParentTeamPermitted?: boolean) => Promise<Group[]>;
    executeAppCall: (call: AppCallRequest, type: AppCallType) => Promise<AppCallResponse<unknown>>;
    getAppsBindings: (userID: string, channelID: string) => Promise<AppBinding[]>;
    getGroupsAssociatedToTeam: (teamID: string, q?: string, page?: number, perPage?: number, filterAllowReference?: boolean) => Promise<{
        groups: Group[];
        total_group_count: number;
    }>;
    getGroupsAssociatedToChannel: (channelID: string, q?: string, page?: number, perPage?: number, filterAllowReference?: boolean) => Promise<{
        groups: Group[];
        total_group_count: number;
    }>;
    getAllGroupsAssociatedToTeam: (teamID: string, filterAllowReference?: boolean, includeMemberCount?: boolean) => Promise<GroupsWithCount>;
    getAllGroupsAssociatedToChannelsInTeam: (teamID: string, filterAllowReference?: boolean) => Promise<{
        groups: RelationOneToOne<Channel, Group>;
    }>;
    getAllGroupsAssociatedToChannel: (channelID: string, filterAllowReference?: boolean, includeMemberCount?: boolean) => Promise<GroupsWithCount>;
    patchGroupSyncable: (groupID: string, syncableID: string, syncableType: string, patch: SyncablePatch) => Promise<GroupSyncable>;
    patchGroup: (groupID: string, patch: GroupPatch) => Promise<Group>;
    getRedirectLocation: (urlParam: string) => Promise<void> | Promise<{
        location: string;
    }>;
    createBot: (bot: Bot) => Promise<Bot>;
    patchBot: (botUserId: string, botPatch: BotPatch) => Promise<Bot>;
    getBot: (botUserId: string) => Promise<Bot>;
    getBots: (page?: number, perPage?: number) => Promise<Bot[]>;
    getBotsIncludeDeleted: (page?: number, perPage?: number) => Promise<Bot[]>;
    getBotsOrphaned: (page?: number, perPage?: number) => Promise<Bot[]>;
    disableBot: (botUserId: string) => Promise<Bot>;
    enableBot: (botUserId: string) => Promise<Bot>;
    assignBot: (botUserId: string, newOwnerId: string) => Promise<Bot>;
    getCloudProducts: () => Promise<Product[]>;
    createPaymentMethod: () => Promise<unknown>;
    getCloudCustomer: () => Promise<CloudCustomer>;
    updateCloudCustomer: (customerPatch: CloudCustomerPatch) => Promise<CloudCustomer>;
    updateCloudCustomerAddress: (address: Address) => Promise<CloudCustomer>;
    confirmPaymentMethod: (stripeSetupIntentID: string) => Promise<unknown>;
    getSubscription: () => Promise<Subscription>;
    getSubscriptionStats: () => Promise<SubscriptionStats>;
    getRenewalLink: () => Promise<{
        renewal_link: string;
    }>;
    getInvoices: () => Promise<Invoice[]>;
    getInvoicePdfUrl: (invoiceId: string) => string;
    teamMembersMinusGroupMembers: (teamID: string, groupIDs: string[], page: number, perPage: number) => Promise<UsersWithGroupsAndCount>;
    channelMembersMinusGroupMembers: (channelID: string, groupIDs: string[], page: number, perPage: number) => Promise<UsersWithGroupsAndCount>;
    getSamlMetadataFromIdp: (samlMetadataURL: string) => Promise<SamlMetadataResponse>;
    setSamlIdpCertificateFromMetadata: (certData: string) => Promise<StatusOK>;
    getInProductNotices: (teamId: string, client: string, clientVersion: string) => Promise<ProductNotices>;
    updateNoticesAsViewed: (noticeIds: string[]) => Promise<StatusOK>;
    sendAdminUpgradeRequestEmail: () => Promise<StatusOK>;
    sendAdminUpgradeRequestEmailOnJoin: () => Promise<StatusOK>;
    doFetch: <T>(url: string, options: Options) => Promise<T>;
    doFetchWithResponse: <T>(url: string, options: Options) => Promise<ClientResponse<T>>;
    trackEvent(category: string, event: string, props?: any): void;
    pageVisited(category: string, name: string): void;
}
export declare class ClientError extends Error implements ServerError {
    url?: string;
    intl?: {
        id: string;
        defaultMessage: string;
        values?: any;
    };
    server_error_id?: string;
    status_code?: number;
    constructor(baseUrl: string, data: ServerError);
}
